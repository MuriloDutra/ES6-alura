{"version":3,"sources":["../../app-es6/services/ConnectionFactory.js"],"names":["stores","version","dbName","connection","close","ConnectionFactory","Error","Promise","resolve","reject","openRequest","window","indexedDB","open","onupgradeneeded","_createStores","event","target","result","onsuccess","bind","onerror","console","log","error","name","forEach","objectStoreNames","contains","store","deleteObjectStore","createObjectStore","autoIncrement"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAMA,kB,GAAS,CAAC,aAAD,C;AACTC,mB,GAAU,C;AACVC,kB,GAAS,Y;AAEXC,sB,GAAa,I;AACbC,iB,GAAQ,I;;yCAGCC,iB;AAET,6CAAa;AAAA;;AACT,0BAAM,IAAIC,KAAJ,CAAU,uDAAV,CAAN;AACH;;;;oDAGqB;AAClB,+BAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;;AAEpC,gCAAIC,cAAcC,OAAOC,SAAP,CAAiBC,IAAjB,CAAsBX,MAAtB,EAA8BD,OAA9B,CAAlB,CAFoC,CAEsB;;AAE1DS,wCAAYI,eAAZ,GAA8B,iBAAS;AACnCT,kDAAkBU,aAAlB,CAAgCC,MAAMC,MAAN,CAAaC,MAA7C,EADmC,CACmB;AACzD,6BAFD;;AAIAR,wCAAYS,SAAZ,GAAwB,iBAAS;AAC7B,oCAAG,CAAChB,UAAJ,EAAe;AAAE;AACbA,iDAAaa,MAAMC,MAAN,CAAaC,MAA1B;AACAd,4CAAQD,WAAWC,KAAX,CAAiBgB,IAAjB,CAAsBjB,UAAtB,CAAR,CAFW,CAEgC;AAC3CA,+CAAWC,KAAX,GAAmB,YAAU;AAAE;AAC3B,8CAAM,IAAIE,KAAJ,CAAU,+CAAV,CAAN;AACH,qCAFD;AAGH;;AAEDE,wCAAQL,UAAR,EAT6B,CASR;AACxB,6BAVD;;AAYAO,wCAAYW,OAAZ,GAAsB,iBAAS;AAC3BC,wCAAQC,GAAR,CAAYP,MAAMC,MAAN,CAAaO,KAAzB;AACAf,uCAAOO,MAAMC,MAAN,CAAaO,KAAb,CAAmBC,IAA1B,EAF2B,CAEM;AACpC,6BAHD;AAIH,yBAxBM,CAAP;AAyBH;;;kDAGoBtB,U,EAAW;AAC5BH,+BAAO0B,OAAP,CAAe,iBAAS;;AAEpB,gCAAGvB,WAAWwB,gBAAX,CAA4BC,QAA5B,CAAqCC,KAArC,CAAH,EAAmD;AAC/C1B,2CAAW2B,iBAAX,CAA6BD,KAA7B,EAHgB,CAGuB;;AAE3C1B,uCAAW4B,iBAAX,CAA6BF,KAA7B,EAAoC,EAACG,eAAe,IAAhB,EAApC,EALoB,CAKwC;AAC/D,yBAND;AAOH;;;sDAGuB;AACpB,4BAAG7B,UAAH,EAAc;AACVC;AACA;AACAD,yCAAa,IAAb;AACH;AACJ","file":"ConnectionFactory.js","sourcesContent":["const stores = ['negociacoes'];\nconst version = 4;\nconst dbName = 'aluraframe';\n\nlet connection = null;\nlet close = null;\n\n\nexport class ConnectionFactory{\n\n    constructor(){\n        throw new Error('Não é possível criar instâncias de ConnectionFactory.');\n    }\n\n\n    static getConnection(){\n        return new Promise((resolve, reject) => {\n\n            let openRequest = window.indexedDB.open(dbName, version); //Requisitando abertura de conexão\n\n            openRequest.onupgradeneeded = event => {\n                ConnectionFactory._createStores(event.target.result); //Cria as Stores\n            };\n\n            openRequest.onsuccess = event => {\n                if(!connection){ //Verificando se a conexão existe\n                    connection = event.target.result;\n                    close = connection.close.bind(connection); //Obtendo o método original com seu THIS original\n                    connection.close = function(){ //sobrescrevendo o método close()\n                        throw new Error('Não é permitido fechar diretamente a conexão.');\n                    }\n                }\n                \n                resolve(connection); //Caso tudo dê certo\n            };\n\n            openRequest.onerror = event => {\n                console.log(event.target.error);\n                reject(event.target.error.name); //Caso um erro aconteça\n            };\n        });\n    }\n\n\n    static _createStores(connection){\n        stores.forEach(store => {\n\n            if(connection.objectStoreNames.contains(store))    //Verificando se a ObjectStore já existe\n                connection.deleteObjectStore(store);   //Deletando a ObjectStore já existente. Para atualizar uma ObjectStore, é necessário deletá-la e criá-la novamente\n\n            connection.createObjectStore(store, {autoIncrement: true}); //Criando a ObjectStore    \n        });\n    }\n\n\n    static closeConnection(){\n        if(connection){\n            close();\n            //Reflect.apply(close, connection, []); Outra maneira de preservar o THIS de 'close'\n            connection = null;\n        }\n    }\n}"]}