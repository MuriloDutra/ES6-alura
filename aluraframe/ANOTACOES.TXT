    -------------------- SINTAXE --------------------

-   Existe uma segunda maneira de declarar váriaveis. Invés de usarmos a palavra
    'var', podemos usar 'let'. Com esse tipo de declaração, a váriavel só estará
    disponível no bloco em que foi declarada.

    EXEMPLO:
        for(let i = 0; i <= 100; i++){
                console.log(i);
        }

    alert(i);

    Como a váriavel 'i' foi declarada usando 'let' dentro do 'for', caso eu
    tente acessar 'i' no alert(), um erro será mostrado, pois 'i' só está
    acessível dentro de seu bloco, que é o 'for'.


-   O "Spread operator" transforma os elemento de um array, em parâmetros.
    Por exemplo, se tivermos o seguinte array: [1,2,3,4,5], e queira passar ele
    como parâmetro para um função, basta chamar a função e passá-lo.

    EXEMPLO:
        let array = [1,2,3,4,5];
        exemplo(...array);

        function exemplo(num1, num2){
            //código
        }

    No exemplo acima, a função exemplo() requisita dois parâmetros, mas o vetor
    possui CINCO posições, o que irá ocorrer? O Spread Operator passará apenas
    a quantidade requisitada de parâmetros, no caso são DUAS posições do vetor.
    As outras TRÊS posições serão ignoradas.

    Resumindo, o Spread Operator, "...", serve para você quebrar um vetor ou string
    e transformar cada posição deles em parâmetros.


-   No ES6 há uma nova maneira de declarar FUNÇÕES, tradicionalmente, nós usamos
    a palavra "function" para declarar uma função, com o ES6 existe o conceito de
    ARROWS FUNCTIONS, podemos declarar uma função apenas usando "=>" uma flecha.

    EXEMPLO:
        //FUNÇÃO TRADICIONAL
        function soma(num1, num2){
            return num1 + num2;
        }

        //FUNÇÃO "ARROW"
        (num1, num2) => num1 + num2;

    Se a ARROW FUNCTION tiver apenas uma linha, nãoé necessário por "{ }" e 
    também não é necessário colocar o comando de "return".

    Outra vantagem das ARROWS FUNCTIONS é que o contexto delas, ou seja, o 'this' é léxico. 
    Isso significa que o contexto/this em que ela foi criada, será mantido até o final de sua execução.
    Com o método tradicional, usando a palavra 'function' o 'this' é dinâmico, ele muda atráves do escopo em que estiver sendo executado.


-   Para herdar uma classe externa para a sua, é muito simples. Basta adicionar a palavra "extends" e o nome da classe.
    E caso o construtor precise receber algum parâmetro, este valor deve ser passado para o construtor da classe "pai",
    a que está sendo herdada.

    EXEMPLO:
        class NegociacoesView extends View{
            
            constructor(elemento){
                super(elemento);
            }
        }

    O comando "super" é usado para acessar a classe "pai", a que está sendo herdada. No exemplo acima,
    estou acessando a classe "pai" e passando para o seu construtor o parâmetro "elemento".

    Mas caso não queira usar o comando 'super()', passando verbalmente o parâmetro do construtor da classe "filha" para o construtor da classe "pai", 
    basta apagar o construtor da "filha". O javascript já considera que o elemento passado para o construtor "filho", deve ser redirecionado para a classe "pai".
    Por isso a classe "filha" pode não possuir construtor, que mesmo assim, o parâmetro será redirecionado para a classe "pai".


-   Caso sua classe precise herdar de outra, é importante se atentar aos parâmetros e construtor. Como já sabemos, 
    caso você não declare um construtor na classe 'filha', todos os parâmetros irão direto para a classe 'pai'. 
    Mas supondo que sua classe 'filha' receba dois parâmetros diferentes, um será usado na classe 'pai' e outro na 'filha', como proceder? Declaro construtor?
    Sim, um construtor deve ser declarado na classe, ele será usado para receber o parâmetro da classe 'filha' e passar o outro parâmetro para o 'pai'.

    EXEMPLO:
        class Secretaria extends Funcionario {

            constructor(nome, funcionario) {
                super(nome); // cuidado, tem que ser a primeira instrução!
                this._funcionario = funcionario;
            }
        }

    No exemplo acima, o parâmetro 'nome' está sendo redirecionado para a classe 'pai', que no exemplo é Funcionario, usando o comando 'super()'.
    E o parâmetro 'funcionario', está sendo usado na própria classe 'filha', que no caso é Secretaria.
    -------------------- CONCEITOS --------------------

-   Quando for criar um atributo de uma classe, é necessário colocar 
    a palavra 'this' antes, para que cada instância tenha seu próprio atributo.

    EXEMPLO:
        constructor(){
            this._data = new Date();
            this._quantidade = 1;
            this._valor = 0;
        }


-   Por convenção, quando se quer especificar que um atributo deve ser protegido,
    ou seja, só pode ser manipulado dentro de sua própria classe, coloca-se um
    '_' antes do nome do atributo.

    EXEMPLO:
            this._data = new Date();
            this._quantidade = 1;
            this._valor = 0;


-   Para criar um método totalmente para leitura, ou seja, o método apenas
    retorna o valor de um atributo, é necessário colocar a palavra 'get'.

    EXEMPLO:
        get valor(){
            return this._valor;
        }


-   Clonagem de um objeto Date().

    EXEMPLO:
        get data(){
            return new Date(this._data.getTime());
        }

    Estou criando um novo objeto Date baseado no meu this._data já existente.
    
    Portanto, quando o valor for retornando, será um objeto Date baseado 
    no meu atributo data, não o atributo em si. É um clone, meu objeto original
    está protegido, pois uma cópia foi retornada.


-   É possível criar atalhos para comando recorrentes no Javascript.
    Por exemplo o comando 'document.querySelector'. Para criar o atalho, basta
    declarar uma variável e fazer a variável receber o comando.

    EXEMPLO:
        let $ = document.querySelector.bind(document);
        let inputData = $('#data');

    Como 'querySelector' é um método de 'document', caso apenas coloque o
    comando na variável '$', 'querySelector' perdera o seu this.

    Antes era 'document' e agora passa a ser '$', então ocorrerá um erro.
    Para evitar isso, usa-se a função bind() para ligar 'querySelector' a
    'document'. Assim mantendo o seu this padrão.


-   Caso uma classe que você possua, não tenha um constructor() definido,
    internamente, é a mesma coisa de ter um constructor(), mas ele vazio.
    Ou seja,

    EXEMPLO:
        Não declarar um constructor, é a mesma coisa de fazer isso

        constructor(){}


-   Caso você declare um método/function como "static", você não precisa instanciar
    o Objeto ao qual esse método pertence.

    EXEMPLO:
        Eu possuo o objeto "Pessoa", que dentro de si, contém a função
        getIdade() que NÃO É "static", para eu ter acesso a esse método,
        precisaria fazer:

            let pessoa = new Pessoa();
            console.log(pessoa.getIdade());

        MAS se o método É "static", basta fazer:
        
            console.log(Pessoa.getIdade());

    Portanto, qunado o método é "static", não preciso instanciar um objeto para
    acessá-lo.


    -------------------- FUNÇÕES/MÉTODOS --------------------

-   Para congelar um Objeto e deixá-lo inalterável, mesmo chamando diretamente
    seus atributos. Basta chama a função Object.freeze() e passar o objeto como
    parâmetro.

    EXEMPLO:
        constructor(data, quantidade, valor){
            this._data = data;
            this._quantidade = quantidade;
            this._valor = valor;

            Object.freeze(this);
        }

    É recomendável fazer isso no CONSTRUTOR, pois quando a classe for
    instânciada, o objeto que for retornado, não será possível mexer 
    em seus atributos. Assim protegendo o objeto.


-   A classe Date(), possui o método setDate(), para ser inserido um valor
    de data. Basta passar o dia que deseja.
    
    EXEMPLO:
        var data = new Date();
        data.setDate(27);


-   O método replace(), serve para você substituir uma string por outra.
    Ela recebe dois parâmetros, a string que será substituída e o nova valor
    a ser posto no lugar.

    EXEMPLO:
        var msg = "PHP é uma ótima linguagem";
        var resultado = msg.replace("PHP", "Javascript");
        //Valor retornado: "JavaScript é uma ótima linguagem"

    Mas supondo que na string  acima a palavra 'PHP' estivessa presente
    mais vezes, no exemplo acima, "PHP" só seria substituído na primeira
    vez, no restante da string iria continuar "PHP".

    Para contornar este problema, é necessário usar uma expressão regular.

    EXEMPLO:
        exemplo = "Estudando JavaScript! JavaScript é uma linguagem dinâmica";
        resultado = exemplo.replace(/JavaScript/g, "PHP");
        // Valor retornado: “Estudando PHP! PHP é uma linguagem dinâmica”


-   Método split() serve para você separar pedaços de uma string em um array.
    A função irá separar a string considerando um parâmetro seu. E a cada vez
    que ele encontrar esse parâmetro, quebrará a string, transformando esse
    pedaço em uma posição do array.

    EXEMPLO:
        let data = '2019-09-19';
        let resultado = data.split('-');
        // Valor retornado: ['2019','09','19'];


-   A função map() serve para percorrer um vetor, ao final do percurso, a função
    retorna um novo vetor. Nesse meio tempo, você pode modificar o vetor,
    a modificação será feita no NOVO vetor, o antigo se manterá o mesmo.

        EXEMPLO:
            let vetor = [10, 20, 30];
                                            //item é cada posição do vetor  
            let novoVetor = vetor.map(function(item){
                return item + 10;
            });

    No exemplo acima, estou fazendo cada posição receber mais 10. Logo o NOVO vetor
    terá valores valores modificados do que o primeiro.


-   A função concat() serve para concatenar duas strings. E ela cria uma nova
    string como resultado das duas anteriores.

        EXEMPLO: 
            return [].concat(this._negociacoes);

    No caso acima, está sendo criado um novo array, que está vazio e será
    retornado. Este vetor que será retornado, está sendo concatenado com
    o vetor "negociacoes", portanto o resultado final será igual ao vetor
    "this._negociacoes".


-   A função join() serve para juntar os elementos de um array e 
    transformá-los em uma string. Portanto, caso a primeira posição seja 
    "Mariana" e a segunda "Ruy Barbosa", caso queira juntar ambas,
    basta usar a função join().

        EXEMPLO:
            let nome = ["Mariana", "Ruy Barbosa"];
            let nomeCompleto = nome.join(" ");

            //Resultado - nomeCompleto: "Mariana Ruy Barbosa"

    Entre os parenteses você pode passar um seperador, ou seja, o que terá
    entre duas posições do vetor. No exemplo acima foi um espaço em branco.
    Mas vamos ver outro exemplo.

        EXEMPLO:
            var fruits = ["Banana", "Orange", "Apple", "Mango"];
            var energy = fruits.join(" and ");

            //Resultado - energy: "Banana and Orange and Apple and Mango"


-   A função reduce() serve para reduzir um vetor de números em apenas
    um único número, você pode somar os números presente ou os subtrair, faça
    a operação que lhe conver.

    EXEMPLO:
        let number = [175, 50, 25];
        let numero = number.reduce((total, n) => total + n, 0.0);
        
        console.log(numero);//o resultado será 250

    A função reduce recebe dois parâmetros: 
    uma função e um valor inicial. Na função interna ao reduce,o primeiro 
    parâmetro é o valor da última iteração, que neste caso é o total. O segundo
    parâmetro é o valor da iteração atual, neste caso, o novo número que queremos somar.

    No exemplo acima, todos os elementos do array foram somados,
    resultando em 250. Outro detalhe do segundo parâmetro, que é o valor
    de inicialização, se o valor passado for 0.0, não é necessário passá-lo então.
    Por default a função considera como ZERO o valor de inicialização.
    

-   Em javascript podemos nos deparar com problemas bem específicos, por exemplo,
    querer executar uma função em outro contexto que não seja no "this" atual.
    Para fazer isso, usaremos a classe Reflect, própria do javascript, e usaremos seu método apply().
    IMPORTANTE: você deve receber o outro contexto, o outro "this" de alguma maneira, no exemplo abaixo será por parâmetro.

    EXEMPLO:                
        constructor(contexto, funcao){
            this._contexto = contexto;
            this._funcao = funcao;
        }

    O parâmetro'contexto' é o outro "this", no qual a função que deseja será executada. E 'funcao' é o método que será executado.

    EXEMPLO:
        Reflect.apply(this._funcao, this._contexto,[this]);

    O primeiro parâmetro é a função que queremos executar.
    O segundo parâmetro é o NOVO contexto, o NOVO "this" no qual a função será executada.
    E o terceiro parâmetro é um array do que "this._funcao" receberá como parâmetro, que no caso é "this", 
    que é diferente de "this._contexto".

    OUTRO EXEMPLO:
        Reflect.apply(this._soma, this._contexto,[1,2,3]);

-------------------- BOAS PRÁTICAS --------------------

-   Uma boa prática a ser adotada é: quando você for usar um método que será
    executado várias vezes, declare as variáveis imutávei fora do método, ou seja, 
    em seu construtor.
    EXEMPLO:

    adiciona(event){
        event.preventDefault();

        console.log(this.inputData.value);
        console.log(this.inputQuantidade.value);
        console.log(this.inputValor.value);
    }
    
    Este método será acionado várias vezes, repare que ele está usando atributos,
    que já foram declarados: this.inputData, this.inputQuantidade e 
    this.inputValor.

    Estes atributos e seus valores foram definidos no construtor, pois eles 
    são imutáveis, sempre que eu for os usar, terão o mesmo valor, portanto
    não faz sentido declará-los várias vezes. Segue código do construtor com
    os atributos.
    EXEMPLO:

    constructor(){
        let $ = document.querySelector.bind(document);

        this.inputData = $('#data');
        this.inputQuantidade = $('#quantidade');
        this.inputValor = $('#valor');
    }